import hashids
from django.conf import settings
from django.utils.translation import gettext

from .exceptions import DecodeHashidError


def encode_id(*real_id, generator=None):
    if not generator:
        generator = hashids.Hashids(salt=settings.HASHID_SALT, min_length=7)
    return generator.encode(*real_id)
def decode_id(hash_id, generator = None):
    if not generator:
        generator = hashids.Hashids(salt=settings.HASHID_SALT, min_length=7)
    l = generator.decode(hash_id)
    if len(l) == 1:
        return l[0]
    else:
        return l

def decode_identifier(identifier, version, keys, generator=None):
    """
    see `generate_identifier`.
    Decodes the identifier generated by `generate_identifier`.
    Provide the same version number as well as the same list of keys as were used to
    encode the id. The keys will be sorted alphabetically.

    :param identifier:
    :param version:
    :param keys:
    :return: returns a dictionary with the values from the identifier mapped to the provided keys
    """
    values = decode_id(identifier, generator=generator)
    try:
        decoded_version = values[0]
    except IndexError as e:
        raise DecodeHashidError(gettext("Identifier could not be decoded: %s") % e)
    if version == decoded_version:
        d = dict()
        keys = sorted(keys)
        for index, key in enumerate(keys, start=1):
            d[key] = values[index]
    else:
        raise DecodeHashidError(gettext("Identifier could not be decoded: %s.") % gettext("version mismatch"))
    return d

def generate_identifier(version, generator=None, **kwargs):
    """
    create an encoded identifier using provided data.
    The keys of the kwargs are sorted alphabetically and inserted as data into the encoded string.
    The values must all be integers!
    :return: the encoded id string
    """
    items = [version]+[kwargs[k] for k in sorted(kwargs.keys())]
    return encode_id(generator=generator, *items)
